apply plugin: 'kotlin-android-extensions'

//apply from: project.rootProject.file('gradle/pom.gradle')

//task emptyJavadoc(type: Jar) {
//    classifier = 'javadoc'
//}
//
//task androidSourcesJar(type: Jar) {
//    classifier = 'sources'
//    from android.sourceSets.main.java.srcDirs
//}
//
//artifacts {
//    archives androidSourcesJar
//}
//
//publishing {
//    publications {
//        android(MavenPublication) {
//            artifact("$buildDir/outputs/aar/client-release.aar")
//            artifact androidSourcesJar
//            artifactId "android"
//
//            //The publication doesn't know about our dependencies, so we have to manually add them to the pom
//            pom.withXml {
//                def dependenciesNode = asNode().appendNode('dependencies')
//
//                //Iterate over the compile dependencies (we don't want the test ones), adding a <dependency> node for each
//                configurations.compile.allDependencies.each {
//                    def dependencyNode = dependenciesNode.appendNode('dependency')
//                    dependencyNode.appendNode('groupId', it.group)
//                    dependencyNode.appendNode('artifactId', it.name)
//                    dependencyNode.appendNode('version', it.version)
//                }
//            }
//        }
//    }
//
//    publications.all {
////        pom.withXml(configureMavenCentralMetadata)
//
//        def type = it.name
//        switch (type) {
//            case 'kotlinMultiplatform':
//                task sourcesJar(type: Jar) {
//                    classifier 'sources'
//                    from kotlin.sourceSets.commonMain.kotlin
//                }
//
//                it.artifactId = "${project.name}-native"
//                it.artifact emptyJar
//                it.artifact stubJavadoc
//                it.artifact sourcesJar
//                break
//            case 'metadata':
//                it.artifactId = "${project.name}-common"
//                break
//            case 'android':
//                it.artifactId = "${project.name}-$type"
//                break
//        }
//
//        pom.withXml { pom ->
//            def dependenciesNode = asNode().getAt("dependencies")[0]
//            if (dependenciesNode == null) return
//            def dependencyNode = dependenciesNode.appendNode('dependency')
//            dependencyNode.appendNode('groupId', "$group")
//            dependencyNode.appendNode('artifactId', "$project.name-common")
//            dependencyNode.appendNode('version', "$project.version")
////            dependencyNode.appendNode('scope', "compile")
//        }
////        pom.withXml { pom ->
////            def dependenciesNode = asNode().getAt("dependencies")[0]
////            if (dependenciesNode == null) return
////            dependenciesNode.dependency.each {
////                it.artifactId.each { node ->
////                    def artifactId = node.text()
////
////                    println("Adding dependency $artifactId")
////                    logger.info("Adding dependency $artifactId")
////
////                    if (!artifactId.startsWith("client") || (!artifactId.endsWith("native") && !artifactId.endsWith("ios"))) return
////
////                    switch (type) {
////                        case 'metadata':
////                            println("Setting value for $type ${artifactId}")
////                            logger.info("Setting value for $type ${artifactId}")
////                            node.setValue("client-common}")
////                            break
////                        case 'jvm':
////                        case 'android':
////                        case 'ios':
////                        case 'js':
////                            println("Setting value for $type ${artifactId}")
////                            logger.info("Setting value for $type ${artifactId}")
////                            node.setValue("${artifactId}")
////                            break
////                    }
////                }
////            }
////        }
////
////        kotlin.targets.all { target ->
////            def publication = publishing.publications.findByName(target.name)
////
////            if (publication != null) {
////                publication.artifact stubJavadoc
////
////                if (target.platformType.name != 'native') {
////                    publication.moduleDescriptorGenerator = null
////                } else {
////                    publication.artifact emptyJar
////                }
////            }
////        }
//    }
//}

android {
    compileSdkVersion 28
    testOptions.unitTests.includeAndroidResources = true

    defaultConfig {
        minSdkVersion 21
        targetSdkVersion 28
        versionCode 1
        versionName "1.0"
        testInstrumentationRunner "androidx.test.runner.AndroidJUnitRunner"
    }

    compileOptions {
        sourceCompatibility JavaVersion.VERSION_1_8
        targetCompatibility JavaVersion.VERSION_1_8
    }

    buildTypes {
        release {
            minifyEnabled false
            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
        }

        //This is for MultiplatformSettings
        debug {
            // MPP libraries don't currently get this resolution automatically
            matchingFallbacks = ['release']
        }
    }

    packagingOptions {
        exclude 'META-INF/DEPENDENCIES'
        exclude 'META-INF/LICENSE'
        pickFirst 'META-INF/*'
    }
}

repositories {
    google()
    mavenCentral()
    jcenter()
    maven { url "https://kotlin.bintray.com/kotlinx" }
}

//project.afterEvaluate {
//    bintrayUpload.dependsOn(assembleRelease)
//}

// Workaround for https://youtrack.jetbrains.com/issue/KT-27170
//configurations {
//    compileClasspath
//}